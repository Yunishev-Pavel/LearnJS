1.Сколько типов данных в JS?
2.Что возвращают и как работают операторы?  
> >= >= < <= == === && || ! !!  
  
3.Как работают сравнения на разных типах?  
4.Сравнения между undefined, null, NaN  
5.Почему switch не называется циклом?  
6.Что такое функция?


##### `'use strict'` включает строгий режим выполнения JavaScript. Эта строка должна располагаться в самом начале скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на действия, которые ранее пропускал. Если строгий режим был включён, то отключить его для файла уже нельзя.
Строгий режим делает следующее:

- Выбрасывает ошибки, когда в коде используются некоторые небезопасные конструкции.
- Выключает функции языка, которые запутывают код и потому не должны использоваться.
- Предотвращает использование слов, которые могут быть использованы в качестве ключевых в будущем.

## [Переменная](https://learn.javascript.ru/variables#peremennaya)

[Переменная](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

## [Имена переменных](https://learn.javascript.ru/variables#variable-naming)

В JavaScript есть два ограничения, касающиеся имён переменных:

1. Имя переменной должно содержать только буквы, цифры или символы `$` и `_`.
2. Первый символ не должен быть цифрой.

# const

Значение констант не может быть изменено новым присваиванием, а также не может быть переопределено. Константы (`const`) подчиняются области видимости уровня блока так же, как переменные, объявленные с использованием ключевого слова [`let`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let).
// Примечание: Идентификаторы констант могут быть объявлены как в верхнем,
// так и в нижнем регистре. Но правилом хорошего тона является использование
// верхнего регистра.

// определим MY_FAV как константу и присвоим ей значение 7
const MY_FAV = 7;

// данное присваивание выдаст ошибку - Uncaught TypeError: Assignment to constant variable.
MY_FAV = 20;

// напечатает 7
console.log("my favorite number is: " + MY_FAV);

// попробуем переопределить константу, будет брошено исключение - Uncaught SyntaxError: Identifier 'MY_FAV' has already been declared
const MY_FAV = 20;

// имя MY_FAV зарезервировано константой выше, данная операция
// выкинет исключение
var MY_FAV = 20;

// здесь также будет ошибка
let MY_FAV = 20;

// Важно отметить свойства области видимости уровня блока
if (MY_FAV === 7) {
    // Всё нормально. Создать константу или переменную MY_FAV можно.
    // (работает так же как и let при объявлении в блоке переменных, которые не const)
    const MY_FAV = 20;

    // MY_FAV теперь 20
    console.log("my favorite number is " + MY_FAV);

    // это попадёт в глобальный контекст и выдаст ошибку
    var MY_FAV = 20;
}

// MY_FAV все ещё имеет значение 7
console.log("my favorite number is " + MY_FAV);

// Выдаст ошибку, потому что константа не инициализирована - Uncaught SyntaxError: Missing initializer in const declaration
const FOO;

// const также работает с объектами
const MY_OBJECT = {"key": "value"};

// Попытка переопределить ссылку на объект вызовет исключение - Uncaught TypeError: Assignment to constant variable.
MY_OBJECT = {"OTHER_KEY": "value"};

// но, свойства объекта (ключи) можно изменять
MY_OBJECT.key = "otherValue"; // Используйте Object.freeze() для того, чтобы сделать объект неизменяемым

// То же самое применимо к массивам
const MY_ARRAY = [];
// Например, можно добавлять элементы в массив
MY_ARRAY.push("A"); // ["A"]
// Но менять ссылку на объект массива нельзя. Это вызовет исключение - Uncaught TypeError: Assignment to constant variable
MY_ARRAY = ["B"]

# Значение NaN

Значение `NaN` (Not-A-Number) обозначает не число. Такое значение получается тогда, когда вы пытаетесь делать математические операции не с числами, а с чем-то другим. К примеру, такое значение даст попытка умножить строку на число:

`alert('abc' * 3); // выведет NaN`

Любые операции с `NaN` приводят к тому, что результатом все равно остается `NaN`:

`alert(NaN + 1); // выведет NaN`

# Типы данных
В JavaScript есть 8 основных типов данных.

- Семь из них называют «примитивными» типами данных:
    - `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(253-1)`.
    - `bigint` для целых чисел произвольной длины.
    - `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    - `boolean` для `true`/`false`.
    - `null` для неизвестных значений – отдельный тип, имеющий одно значение `null`.
    - `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение `undefined`.
    - `symbol` для уникальных идентификаторов.
- И один не является «примитивным» и стоит особняком:
    - `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

- Имеет две формы: `typeof x` или `typeof(x)`.
- Возвращает строку с именем типа. Например, `"string"`.
- Для `null` возвращается `"object"` – это ошибка в языке, на самом деле это не объект



# Взаимодействие: alert, prompt, confirm
`alert`

показывает сообщение.

`prompt`

показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или `null`, если была нажата кнопка «Отмена» или Esc с клавиатуры.

`confirm`

показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает `true`, если нажата OK, и `false`, если нажата кнопка «Отмена» или Esc с клавиатуры.

# Преобразование типов

| Значение       | Становится…                                                                                                                                                            |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`    | `NaN`                                                                                                                                                                  |
| `null`         | `0`                                                                                                                                                                    |
| `true / false` | `1 / 0`                                                                                                                                                                |
| `string`       | Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |

Операторы `++` и `--` могут быть расположены не только после, но и до переменной.

- Когда оператор идёт после переменной — это «постфиксная форма»: `counter++`.
- «Префиксная форма» — это когда оператор идёт перед переменной: `++counter`

value = String(value); // теперь value это строка "true"
alert(typeof value); // string
### String
String(123) // '123'       
String(-12.3) // '-12.3'
String(null) // 'null'
String(undefined) // 'undefined'
String(true) // 'true'
String(false) // 'false'
String(function () {}) // 'function () {}'
String({}) // '[object Object]'
String({ key: 42 }) // '[object Object]'
String([]) // ''
String([1, 2]) // '1,2'
### Number
Number('123') // 123
Number('123.4') // 123.4
Number('123,4') // NaN
Number('') // 0
Number(null) // 0
Number(undefined) // NaN
Number(true) // 1
Number(false) // 0
Number(function () {}) // NaN
Number({}) // NaN
Number([]) // 0
Number([1]) // 1
Number([1, 2]) // NaN

### **Typeof**

// 1. Undefined
typeof undefined === 'undefined'

// 2. Boolean, логический
typeof true === 'boolean'
typeof false === 'boolean'

// 3. Number, число
typeof 42 === 'number'
typeof 4.2 === 'number'
typeof -42 === 'number'
typeof Infinity === 'number'
typeof -Infinity === 'number'

// 4. String, строка
typeof '' === 'string'
typeof 'string' === 'string'
typeof 'number' === 'string'
typeof 'boolean' === 'string'

// 5. Symbol, символ, ES6
typeof Symbol() === 'symbol'

// 6. BigInt, большое число, ES6
typeof 9007199254740991n === 'bigint'
typeof BigInt(9007199254740991) === 'bigint'

// 7. Null
typeof null === 'object'


## [Сравнение с null и undefined](https://learn.javascript.ru/comparison#sravnenie-s-null-i-undefined)

Поведение `null` и `undefined` при сравнении с другими значениями — особое:

При строгом равенстве `===`

Эти значения различны, так как различны их типы.


``` `alert``(` `null` `===` `undefined` `)``;` `// false` ```

При нестрогом равенстве `==`

Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
alert(` `null == undefined` `); // true
При использовании математических операторов и других операторов сравнения `< > <= >=`. Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом порядке.
- Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
- Значения `null` и `undefined` равны `==` друг другу и не равны любому другому значению.
- Будьте осторожны при использовании операторов сравнений вроде `>` и `<` с переменными, которые могут принимать значения `null/undefined`. Хорошей идеей будет сделать отдельную проверку на `null/undefined`


# Логические операторы

В JavaScript есть семь логических операторов:

- `||` (ИЛИ)
    - `||=` (Оператор логического присваивания ИЛИ)
- `&&` (И)
    - `&&=` (Оператор логического присваивания И)
- `!` (НЕ)
- `??` (Оператор нулевого слияния)
    - `??=` (Оператор нулевого присваивания)

### [ИЛИ "||" находит первое истинное значение](https://learn.javascript.ru/logical-operators#or-finds-the-first-truthy-value)

```javascript
result = value1 || value2 || value3;
```

Оператор `||` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (`false`), возвращает последний из них.

Значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ `||` возвращает первое истинное значение или последнее, если такое значение не найдено

## [||= (Логическое присваивание ИЛИ)](https://learn.javascript.ru/logical-operators#logicheskoe-prisvaivanie-ili)

Оператор логического присваивания ИЛИ `||=` записывается как обычный ИЛИ `||` с добавлением символа присваивания `=`. Такая запись не случайна, так как результат выполнения данного оператора напрямую зависит от действий уже известного нам `||`.

Вот его синтаксис:

`` a `||=` b`;` ``

Оператор `||=` принимает два операнда и выполняет следующие действия:

- Вычисляет операнды слева направо.
- Конвертирует `a` в логическое значение.
- Если `a` ложно, присваивает `a` значение `b`.

## [&& (И)](https://learn.javascript.ru/logical-operators#i)

### [И «&&» находит первое ложное значение](https://learn.javascript.ru/logical-operators#i-nahodit-pervoe-lozhnoeznachenie)

При нескольких подряд операторах И:

`` result `=` value1 `&&` value2 `&&` value3`;` ``

Оператор `&&` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое _ложное_ значение, а ИЛИ –  первое _истинное_.



# Условный (тернарный) оператор

**Условный (тернарный) оператор** - единственный оператор в JavaScript, принимающий три операнда: условие, за которым следует знак вопроса (?), затем выражение, которое выполняется, если условие истинно, сопровождается двоеточием (:), и, наконец, выражение, которое выполняется, если условие ложно. Он часто используется в качестве сокращённого варианта инструкции [`if...else`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/if...else).

# Операторы нулевого слияния и присваивания: '??', '??='
Оператор нулевого слияния представляет собой два вопросительных знака `??`.

Так как он обрабатывает `null` и `undefined` одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение «определено», если оно не равняется ни `null`, ни `undefined`.

Результат выражения `a ?? b` будет следующим:

- если `a` определено, то `a`,
- если `a` не определено, то `b`.

Иначе говоря, оператор `??` возвращает первый аргумент, если он не `null/undefined`, иначе второй.

Оператор нулевого слияния не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно, которое «определено».

Вот как можно переписать выражение `result = a ?? b`, используя уже знакомые нам операторы:

``` result `=` `(`a `!==` `null` `&&` a `!==` `undefined``)` `?` a `:` b`;` ```

- Оператор нулевого слияния `??` — это быстрый способ выбрать первое «определённое» значение из списка.
    
    Используется для присвоения переменным значений по умолчанию:
    
    ``` `// будет height=100, если переменная height равна null или undefined` height `=` height `??` `100``;` ```
    
- Оператор `??` имеет очень низкий приоритет, лишь немного выше, чем у `?` и `=`, поэтому при использовании его в выражении, скорее всего, потребуются скобки.
    
- Запрещено использовать вместе с `||` или `&&` без явно указанного приоритета, то есть без скобок.
    
- Для присвоения переменной значения в зависимости от того, «определена» она или нет, используется оператор нулевого присваивания `??=`