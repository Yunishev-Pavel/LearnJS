# LearnJS
1.Сколько типов данных в JS?
2.Что возвращают и как работают операторы?  
> >= >= < <= == === && || ! !!  
  
3.Как работают сравнения на разных типах?  
4.Сравнения между undefined, null, NaN  
5.Почему switch не называется циклом?  
6.Что такое функция?


##### `'use strict'` включает строгий режим выполнения JavaScript. Эта строка должна располагаться в самом начале скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на действия, которые ранее пропускал. Если строгий режим был включён, то отключить его для файла уже нельзя.
Строгий режим делает следующее:

- Выбрасывает ошибки, когда в коде используются некоторые небезопасные конструкции.
- Выключает функции языка, которые запутывают код и потому не должны использоваться.
- Предотвращает использование слов, которые могут быть использованы в качестве ключевых в будущем.

## [Переменная](https://learn.javascript.ru/variables#peremennaya)

[Переменная](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

## [Имена переменных](https://learn.javascript.ru/variables#variable-naming)

В JavaScript есть два ограничения, касающиеся имён переменных:

1. Имя переменной должно содержать только буквы, цифры или символы `$` и `_`.
2. Первый символ не должен быть цифрой.

# const

Значение констант не может быть изменено новым присваиванием, а также не может быть переопределено. Константы (`const`) подчиняются области видимости уровня блока так же, как переменные, объявленные с использованием ключевого слова [`let`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let).
// Примечание: Идентификаторы констант могут быть объявлены как в верхнем,
// так и в нижнем регистре. Но правилом хорошего тона является использование
// верхнего регистра.

// определим MY_FAV как константу и присвоим ей значение 7
const MY_FAV = 7;

// данное присваивание выдаст ошибку - Uncaught TypeError: Assignment to constant variable.
MY_FAV = 20;

// напечатает 7
console.log("my favorite number is: " + MY_FAV);

// попробуем переопределить константу, будет брошено исключение - Uncaught SyntaxError: Identifier 'MY_FAV' has already been declared
const MY_FAV = 20;

// имя MY_FAV зарезервировано константой выше, данная операция
// выкинет исключение
var MY_FAV = 20;

// здесь также будет ошибка
let MY_FAV = 20;

// Важно отметить свойства области видимости уровня блока
if (MY_FAV === 7) {
    // Всё нормально. Создать константу или переменную MY_FAV можно.
    // (работает так же как и let при объявлении в блоке переменных, которые не const)
    const MY_FAV = 20;

    // MY_FAV теперь 20
    console.log("my favorite number is " + MY_FAV);

    // это попадёт в глобальный контекст и выдаст ошибку
    var MY_FAV = 20;
}

// MY_FAV все ещё имеет значение 7
console.log("my favorite number is " + MY_FAV);

// Выдаст ошибку, потому что константа не инициализирована - Uncaught SyntaxError: Missing initializer in const declaration
const FOO;

// const также работает с объектами
const MY_OBJECT = {"key": "value"};

// Попытка переопределить ссылку на объект вызовет исключение - Uncaught TypeError: Assignment to constant variable.
MY_OBJECT = {"OTHER_KEY": "value"};

// но, свойства объекта (ключи) можно изменять
MY_OBJECT.key = "otherValue"; // Используйте Object.freeze() для того, чтобы сделать объект неизменяемым

// То же самое применимо к массивам
const MY_ARRAY = [];
// Например, можно добавлять элементы в массив
MY_ARRAY.push("A"); // ["A"]
// Но менять ссылку на объект массива нельзя. Это вызовет исключение - Uncaught TypeError: Assignment to constant variable
MY_ARRAY = ["B"]

# Значение NaN

Значение `NaN` (Not-A-Number) обозначает не число. Такое значение получается тогда, когда вы пытаетесь делать математические операции не с числами, а с чем-то другим. К примеру, такое значение даст попытка умножить строку на число:

`alert('abc' * 3); // выведет NaN`

Любые операции с `NaN` приводят к тому, что результатом все равно остается `NaN`:

`alert(NaN + 1); // выведет NaN`

# Типы данных
В JavaScript есть 8 основных типов данных.

- Семь из них называют «примитивными» типами данных:
    - `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(253-1)`.
    - `bigint` для целых чисел произвольной длины.
    - `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    - `boolean` для `true`/`false`.
    - `null` для неизвестных значений – отдельный тип, имеющий одно значение `null`.
    - `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение `undefined`.
    - `symbol` для уникальных идентификаторов.
- И один не является «примитивным» и стоит особняком:
    - `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

- Имеет две формы: `typeof x` или `typeof(x)`.
- Возвращает строку с именем типа. Например, `"string"`.
- Для `null` возвращается `"object"` – это ошибка в языке, на самом деле это не объект



# Взаимодействие: alert, prompt, confirm
`alert`

показывает сообщение.

`prompt`

показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или `null`, если была нажата кнопка «Отмена» или Esc с клавиатуры.

`confirm`

показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает `true`, если нажата OK, и `false`, если нажата кнопка «Отмена» или Esc с клавиатуры.

# Преобразование типов

| Значение       | Становится…                                                                                                                                                            |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`    | `NaN`                                                                                                                                                                  |
| `null`         | `0`                                                                                                                                                                    |
| `true / false` | `1 / 0`                                                                                                                                                                |
| `string`       | Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |

Операторы `++` и `--` могут быть расположены не только после, но и до переменной.

- Когда оператор идёт после переменной — это «постфиксная форма»: `counter++`.
- «Префиксная форма» — это когда оператор идёт перед переменной: `++counter`

## [Сравнение с null и undefined](https://learn.javascript.ru/comparison#sravnenie-s-null-i-undefined)

Поведение `null` и `undefined` при сравнении с другими значениями — особое:

При строгом равенстве `===`

Эти значения различны, так как различны их типы.


``` `alert``(` `null` `===` `undefined` `)``;` `// false` ```

При нестрогом равенстве `==`

Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
alert(` `null == undefined` `); // true
При использовании математических операторов и других операторов сравнения `< > <= >=`. Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом порядке.
- Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
- Значения `null` и `undefined` равны `==` друг другу и не равны любому другому значению.
- Будьте осторожны при использовании операторов сравнений вроде `>` и `<` с переменными, которые могут принимать значения `null/undefined`. Хорошей идеей будет сделать отдельную проверку на `null/undefined`.